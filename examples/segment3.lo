/**
 * Another interview question solution.
 *
 * Created by: spurcell
 * 2/8/15
 */

dict is {
    "hi","high","land","highland","highlander","the","there","can","be","only","one","on","here","and","an"
};


findWords is (s, log) {

    // base case
    if dict has s {
        //log "FOUND `s`\n";
        reply [s];
    }
    
    length = #s;

    i = 0;

    while i < length {

        // strings are just arrays
        word = s[0..i];

        if dict has word {

            //log "FOUND `word`\n";

            // we need to use the native form to branch on the result because findWords can fail;
            // on failure we just keep chugging; on success we return
            
            findWords <- (s[i+1..], log) -> (following) {
                reply [word] >< following;
            }
        }

        i++;
    }

    // we seem to have run out of string
    fail;
};

// todo -- system of passing in files securely

// idea: a service spec is an input format, reply format, and failure format
// that's it -- no 'exceptions' can bypass the stack

main is (args, system) {
    
    log is system.err.write;
    
    findWords "therecanbeonlyonehighlander", log -> (result) {
        system.out.write "success! found `result`\n";
    }
    ~> () {
        system.out.write "I was not set up for success\n";
        fail;
    }
};


findWordsB is (s, log) {

    // base case
    if dict has s {
        //log "FOUND `s`\n";
        reply [s];
    }
    
    length = #s;

    i = 0;

    while i < length {

        // strings are just arrays
        word = s[0..i];

        if dict has word {

            //log "FOUND `word`\n";

            // we need to use the native form to branch on the result because findWords can fail;
            // on failure we just keep chugging; on success we return
            
            findWords <- (s[i+1..], log) -> (following) {
                reply [word] >< following;
            }
        }

        i++;
    }

    // we seem to have run out of string
    fail;
};

findWordsC is (s, log) {

    // base case
    if dict has s {
        //log "FOUND `s`\n";
        reply [s];
    }
    
    length = #s;

    i = 0;

    while i < length {

        // strings are just arrays
        word = s[0..i];

        if dict has word {

            //log "FOUND `word`\n";

            // we need to use the native form to branch on the result because findWords can fail;
            // on failure we just keep chugging; on success we return
            
            findWords <- (s[i+1..], log) -> (following) {
                reply [word] >< following;
            }
        }

        i++;
    }

    // we seem to have run out of string
    fail;
};

findWordsD is (s, log) {

    // base case
    if dict has s {
        //log "FOUND `s`\n";
        reply [s];
    }
    
    length = #s;

    i = 0;

    while i < length {

        // strings are just arrays
        word = s[0..i];

        if dict has word {

            //log "FOUND `word`\n";

            // we need to use the native form to branch on the result because findWords can fail;
            // on failure we just keep chugging; on success we return
            
            findWords <- (s[i+1..], log) -> (following) {
                reply [word] >< following;
            }
        }

        i++;
    }

    // we seem to have run out of string
    fail;
};

findWordsE is (s, log) {

    // base case
    if dict has s {
        //log "FOUND `s`\n";
        reply [s];
    }
    
    length = #s;

    i = 0;

    while i < length {

        // strings are just arrays
        word = s[0..i];

        if dict has word {

            //log "FOUND `word`\n";

            // we need to use the native form to branch on the result because findWords can fail;
            // on failure we just keep chugging; on success we return
            
            findWords <- (s[i+1..], log) -> (following) {
                reply [word] >< following;
            }
        }

        i++;
    }

    // we seem to have run out of string
    fail;
};

findWordsF is (s, log) {

    // base case
    if dict has s {
        //log "FOUND `s`\n";
        reply [s];
    }
    
    length = #s;

    i = 0;

    while i < length {

        // strings are just arrays
        word = s[0..i];

        if dict has word {

            //log "FOUND `word`\n";

            // we need to use the native form to branch on the result because findWords can fail;
            // on failure we just keep chugging; on success we return
            
            findWords <- (s[i+1..], log) -> (following) {
                reply [word] >< following;
            }
        }

        i++;
    }

    // we seem to have run out of string
    fail;
};

findWordsG is (s, log) {

    // base case
    if dict has s {
        //log "FOUND `s`\n";
        reply [s];
    }
    
    length = #s;

    i = 0;

    while i < length {

        // strings are just arrays
        word = s[0..i];

        if dict has word {

            //log "FOUND `word`\n";

            // we need to use the native form to branch on the result because findWords can fail;
            // on failure we just keep chugging; on success we return
            
            findWords <- (s[i+1..], log) -> (following) {
                reply [word] >< following;
            }
        }

        i++;
    }

    // we seem to have run out of string
    fail;
};

findWordsH is (s, log) {

    // base case
    if dict has s {
        //log "FOUND `s`\n";
        reply [s];
    }
    
    length = #s;

    i = 0;

    while i < length {

        // strings are just arrays
        word = s[0..i];

        if dict has word {

            //log "FOUND `word`\n";

            // we need to use the native form to branch on the result because findWords can fail;
            // on failure we just keep chugging; on success we return
            
            findWords <- (s[i+1..], log) -> (following) {
                reply [word] >< following;
            }
        }

        i++;
    }

    // we seem to have run out of string
    fail;
};

findWordsI is (s, log) {

    // base case
    if dict has s {
        //log "FOUND `s`\n";
        reply [s];
    }
    
    length = #s;

    i = 0;

    while i < length {

        // strings are just arrays
        word = s[0..i];

        if dict has word {

            //log "FOUND `word`\n";

            // we need to use the native form to branch on the result because findWords can fail;
            // on failure we just keep chugging; on success we return
            
            findWords <- (s[i+1..], log) -> (following) {
                reply [word] >< following;
            }
        }

        i++;
    }

    // we seem to have run out of string
    fail;
};

findWordsJ is (s, log) {

    // base case
    if dict has s {
        //log "FOUND `s`\n";
        reply [s];
    }
    
    length = #s;

    i = 0;

    while i < length {

        // strings are just arrays
        word = s[0..i];

        if dict has word {

            //log "FOUND `word`\n";

            // we need to use the native form to branch on the result because findWords can fail;
            // on failure we just keep chugging; on success we return
            
            findWords <- (s[i+1..], log) -> (following) {
                reply [word] >< following;
            }
        }

        i++;
    }

    // we seem to have run out of string
    fail;
};

findWordsK is (s, log) {

    // base case
    if dict has s {
        //log "FOUND `s`\n";
        reply [s];
    }
    
    length = #s;

    i = 0;

    while i < length {

        // strings are just arrays
        word = s[0..i];

        if dict has word {

            //log "FOUND `word`\n";

            // we need to use the native form to branch on the result because findWords can fail;
            // on failure we just keep chugging; on success we return
            
            findWords <- (s[i+1..], log) -> (following) {
                reply [word] >< following;
            }
        }

        i++;
    }

    // we seem to have run out of string
    fail;
};



findWordsB2 is (s, log) {

    // base case
    if dict has s {
        //log "FOUND `s`\n";
        reply [s];
    }
    
    length = #s;

    i = 0;

    while i < length {

        // strings are just arrays
        word = s[0..i];

        if dict has word {

            //log "FOUND `word`\n";

            // we need to use the native form to branch on the result because findWords can fail;
            // on failure we just keep chugging; on success we return
            
            findWords <- (s[i+1..], log) -> (following) {
                reply [word] >< following;
            }
        }

        i++;
    }

    // we seem to have run out of string
    fail;
};

findWordsC2 is (s, log) {

    // base case
    if dict has s {
        //log "FOUND `s`\n";
        reply [s];
    }
    
    length = #s;

    i = 0;

    while i < length {

        // strings are just arrays
        word = s[0..i];

        if dict has word {

            //log "FOUND `word`\n";

            // we need to use the native form to branch on the result because findWords can fail;
            // on failure we just keep chugging; on success we return
            
            findWords <- (s[i+1..], log) -> (following) {
                reply [word] >< following;
            }
        }

        i++;
    }

    // we seem to have run out of string
    fail;
};

findWordsD2 is (s, log) {

    // base case
    if dict has s {
        //log "FOUND `s`\n";
        reply [s];
    }
    
    length = #s;

    i = 0;

    while i < length {

        // strings are just arrays
        word = s[0..i];

        if dict has word {

            //log "FOUND `word`\n";

            // we need to use the native form to branch on the result because findWords can fail;
            // on failure we just keep chugging; on success we return
            
            findWords <- (s[i+1..], log) -> (following) {
                reply [word] >< following;
            }
        }

        i++;
    }

    // we seem to have run out of string
    fail;
};

findWordsE2 is (s, log) {

    // base case
    if dict has s {
        //log "FOUND `s`\n";
        reply [s];
    }
    
    length = #s;

    i = 0;

    while i < length {

        // strings are just arrays
        word = s[0..i];

        if dict has word {

            //log "FOUND `word`\n";

            // we need to use the native form to branch on the result because findWords can fail;
            // on failure we just keep chugging; on success we return
            
            findWords <- (s[i+1..], log) -> (following) {
                reply [word] >< following;
            }
        }

        i++;
    }

    // we seem to have run out of string
    fail;
};

findWordsF2 is (s, log) {

    // base case
    if dict has s {
        //log "FOUND `s`\n";
        reply [s];
    }
    
    length = #s;

    i = 0;

    while i < length {

        // strings are just arrays
        word = s[0..i];

        if dict has word {

            //log "FOUND `word`\n";

            // we need to use the native form to branch on the result because findWords can fail;
            // on failure we just keep chugging; on success we return
            
            findWords <- (s[i+1..], log) -> (following) {
                reply [word] >< following;
            }
        }

        i++;
    }

    // we seem to have run out of string
    fail;
};

findWordsG2 is (s, log) {

    // base case
    if dict has s {
        //log "FOUND `s`\n";
        reply [s];
    }
    
    length = #s;

    i = 0;

    while i < length {

        // strings are just arrays
        word = s[0..i];

        if dict has word {

            //log "FOUND `word`\n";

            // we need to use the native form to branch on the result because findWords can fail;
            // on failure we just keep chugging; on success we return
            
            findWords <- (s[i+1..], log) -> (following) {
                reply [word] >< following;
            }
        }

        i++;
    }

    // we seem to have run out of string
    fail;
};

findWordsH2 is (s, log) {

    // base case
    if dict has s {
        //log "FOUND `s`\n";
        reply [s];
    }
    
    length = #s;

    i = 0;

    while i < length {

        // strings are just arrays
        word = s[0..i];

        if dict has word {

            //log "FOUND `word`\n";

            // we need to use the native form to branch on the result because findWords can fail;
            // on failure we just keep chugging; on success we return
            
            findWords <- (s[i+1..], log) -> (following) {
                reply [word] >< following;
            }
        }

        i++;
    }

    // we seem to have run out of string
    fail;
};

findWordsI2 is (s, log) {

    // base case
    if dict has s {
        //log "FOUND `s`\n";
        reply [s];
    }
    
    length = #s;

    i = 0;

    while i < length {

        // strings are just arrays
        word = s[0..i];

        if dict has word {

            //log "FOUND `word`\n";

            // we need to use the native form to branch on the result because findWords can fail;
            // on failure we just keep chugging; on success we return
            
            findWords <- (s[i+1..], log) -> (following) {
                reply [word] >< following;
            }
        }

        i++;
    }

    // we seem to have run out of string
    fail;
};

findWordsJ2 is (s, log) {

    // base case
    if dict has s {
        //log "FOUND `s`\n";
        reply [s];
    }
    
    length = #s;

    i = 0;

    while i < length {

        // strings are just arrays
        word = s[0..i];

        if dict has word {

            //log "FOUND `word`\n";

            // we need to use the native form to branch on the result because findWords can fail;
            // on failure we just keep chugging; on success we return
            
            findWords <- (s[i+1..], log) -> (following) {
                reply [word] >< following;
            }
        }

        i++;
    }

    // we seem to have run out of string
    fail;
};

findWordsK2 is (s, log) {

    // base case
    if dict has s {
        //log "FOUND `s`\n";
        reply [s];
    }
    
    length = #s;

    i = 0;

    while i < length {

        // strings are just arrays
        word = s[0..i];

        if dict has word {

            //log "FOUND `word`\n";

            // we need to use the native form to branch on the result because findWords can fail;
            // on failure we just keep chugging; on success we return
            
            findWords <- (s[i+1..], log) -> (following) {
                reply [word] >< following;
            }
        }

        i++;
    }

    // we seem to have run out of string
    fail;
};

////////


findWordsBa is (s, log) {

    // base case
    if dict has s {
        //log "FOUND `s`\n";
        reply [s];
    }
    
    length = #s;

    i = 0;

    while i < length {

        // strings are just arrays
        word = s[0..i];

        if dict has word {

            //log "FOUND `word`\n";

            // we need to use the native form to branch on the result because findWords can fail;
            // on failure we just keep chugging; on success we return
            
            findWords <- (s[i+1..], log) -> (following) {
                reply [word] >< following;
            }
        }

        i++;
    }

    // we seem to have run out of string
    fail;
};

findWordsCa is (s, log) {

    // base case
    if dict has s {
        //log "FOUND `s`\n";
        reply [s];
    }
    
    length = #s;

    i = 0;

    while i < length {

        // strings are just arrays
        word = s[0..i];

        if dict has word {

            //log "FOUND `word`\n";

            // we need to use the native form to branch on the result because findWords can fail;
            // on failure we just keep chugging; on success we return
            
            findWords <- (s[i+1..], log) -> (following) {
                reply [word] >< following;
            }
        }

        i++;
    }

    // we seem to have run out of string
    fail;
};

findWordsDa is (s, log) {

    // base case
    if dict has s {
        //log "FOUND `s`\n";
        reply [s];
    }
    
    length = #s;

    i = 0;

    while i < length {

        // strings are just arrays
        word = s[0..i];

        if dict has word {

            //log "FOUND `word`\n";

            // we need to use the native form to branch on the result because findWords can fail;
            // on failure we just keep chugging; on success we return
            
            findWords <- (s[i+1..], log) -> (following) {
                reply [word] >< following;
            }
        }

        i++;
    }

    // we seem to have run out of string
    fail;
};

findWordsEa is (s, log) {

    // base case
    if dict has s {
        //log "FOUND `s`\n";
        reply [s];
    }
    
    length = #s;

    i = 0;

    while i < length {

        // strings are just arrays
        word = s[0..i];

        if dict has word {

            //log "FOUND `word`\n";

            // we need to use the native form to branch on the result because findWords can fail;
            // on failure we just keep chugging; on success we return
            
            findWords <- (s[i+1..], log) -> (following) {
                reply [word] >< following;
            }
        }

        i++;
    }

    // we seem to have run out of string
    fail;
};

findWordsFa is (s, log) {

    // base case
    if dict has s {
        //log "FOUND `s`\n";
        reply [s];
    }
    
    length = #s;

    i = 0;

    while i < length {

        // strings are just arrays
        word = s[0..i];

        if dict has word {

            //log "FOUND `word`\n";

            // we need to use the native form to branch on the result because findWords can fail;
            // on failure we just keep chugging; on success we return
            
            findWords <- (s[i+1..], log) -> (following) {
                reply [word] >< following;
            }
        }

        i++;
    }

    // we seem to have run out of string
    fail;
};

findWordsGa is (s, log) {

    // base case
    if dict has s {
        //log "FOUND `s`\n";
        reply [s];
    }
    
    length = #s;

    i = 0;

    while i < length {

        // strings are just arrays
        word = s[0..i];

        if dict has word {

            //log "FOUND `word`\n";

            // we need to use the native form to branch on the result because findWords can fail;
            // on failure we just keep chugging; on success we return
            
            findWords <- (s[i+1..], log) -> (following) {
                reply [word] >< following;
            }
        }

        i++;
    }

    // we seem to have run out of string
    fail;
};

findWordsHa is (s, log) {

    // base case
    if dict has s {
        //log "FOUND `s`\n";
        reply [s];
    }
    
    length = #s;

    i = 0;

    while i < length {

        // strings are just arrays
        word = s[0..i];

        if dict has word {

            //log "FOUND `word`\n";

            // we need to use the native form to branch on the result because findWords can fail;
            // on failure we just keep chugging; on success we return
            
            findWords <- (s[i+1..], log) -> (following) {
                reply [word] >< following;
            }
        }

        i++;
    }

    // we seem to have run out of string
    fail;
};

findWordsIa is (s, log) {

    // base case
    if dict has s {
        //log "FOUND `s`\n";
        reply [s];
    }
    
    length = #s;

    i = 0;

    while i < length {

        // strings are just arrays
        word = s[0..i];

        if dict has word {

            //log "FOUND `word`\n";

            // we need to use the native form to branch on the result because findWords can fail;
            // on failure we just keep chugging; on success we return
            
            findWords <- (s[i+1..], log) -> (following) {
                reply [word] >< following;
            }
        }

        i++;
    }

    // we seem to have run out of string
    fail;
};

findWordsJa is (s, log) {

    // base case
    if dict has s {
        //log "FOUND `s`\n";
        reply [s];
    }
    
    length = #s;

    i = 0;

    while i < length {

        // strings are just arrays
        word = s[0..i];

        if dict has word {

            //log "FOUND `word`\n";

            // we need to use the native form to branch on the result because findWords can fail;
            // on failure we just keep chugging; on success we return
            
            findWords <- (s[i+1..], log) -> (following) {
                reply [word] >< following;
            }
        }

        i++;
    }

    // we seem to have run out of string
    fail;
};

findWordsKa is (s, log) {

    // base case
    if dict has s {
        //log "FOUND `s`\n";
        reply [s];
    }
    
    length = #s;

    i = 0;

    while i < length {

        // strings are just arrays
        word = s[0..i];

        if dict has word {

            //log "FOUND `word`\n";

            // we need to use the native form to branch on the result because findWords can fail;
            // on failure we just keep chugging; on success we return
            
            findWords <- (s[i+1..], log) -> (following) {
                reply [word] >< following;
            }
        }

        i++;
    }

    // we seem to have run out of string
    fail;
};

findWordsB2a is (s, log) {

    // base case
    if dict has s {
        //log "FOUND `s`\n";
        reply [s];
    }
    
    length = #s;

    i = 0;

    while i < length {

        // strings are just arrays
        word = s[0..i];

        if dict has word {

            //log "FOUND `word`\n";

            // we need to use the native form to branch on the result because findWords can fail;
            // on failure we just keep chugging; on success we return
            
            findWords <- (s[i+1..], log) -> (following) {
                reply [word] >< following;
            }
        }

        i++;
    }

    // we seem to have run out of string
    fail;
};

findWordsC2a is (s, log) {

    // base case
    if dict has s {
        //log "FOUND `s`\n";
        reply [s];
    }
    
    length = #s;

    i = 0;

    while i < length {

        // strings are just arrays
        word = s[0..i];

        if dict has word {

            //log "FOUND `word`\n";

            // we need to use the native form to branch on the result because findWords can fail;
            // on failure we just keep chugging; on success we return
            
            findWords <- (s[i+1..], log) -> (following) {
                reply [word] >< following;
            }
        }

        i++;
    }

    // we seem to have run out of string
    fail;
};

findWordsD2a is (s, log) {

    // base case
    if dict has s {
        //log "FOUND `s`\n";
        reply [s];
    }
    
    length = #s;

    i = 0;

    while i < length {

        // strings are just arrays
        word = s[0..i];

        if dict has word {

            //log "FOUND `word`\n";

            // we need to use the native form to branch on the result because findWords can fail;
            // on failure we just keep chugging; on success we return
            
            findWords <- (s[i+1..], log) -> (following) {
                reply [word] >< following;
            }
        }

        i++;
    }

    // we seem to have run out of string
    fail;
};

findWordsE2a is (s, log) {

    // base case
    if dict has s {
        //log "FOUND `s`\n";
        reply [s];
    }
    
    length = #s;

    i = 0;

    while i < length {

        // strings are just arrays
        word = s[0..i];

        if dict has word {

            //log "FOUND `word`\n";

            // we need to use the native form to branch on the result because findWords can fail;
            // on failure we just keep chugging; on success we return
            
            findWords <- (s[i+1..], log) -> (following) {
                reply [word] >< following;
            }
        }

        i++;
    }

    // we seem to have run out of string
    fail;
};

findWordsF2a is (s, log) {

    // base case
    if dict has s {
        //log "FOUND `s`\n";
        reply [s];
    }
    
    length = #s;

    i = 0;
    

    findWordsG2a is (s, log) {

        // base case
        if dict has s {
            //log "FOUND `s`\n";
            reply [s];
        }
    
        length = #s;

        i = 0;
    

        findWordsH2a is (s, log) {

            // base case
            if dict has s {
                //log "FOUND `s`\n";
                reply [s];
            }
    
            length = #s;

            i = 0;
    

            findWordsI2a is (s, log) {

                // base case
                if dict has s {
                    //log "FOUND `s`\n";
                    reply [s];
                }
    
                length = #s;

                i = 0;
    

                findWordsJ2a is (s, log) {

                    // base case
                    if dict has s {
                        //log "FOUND `s`\n";
                        reply [s];
                    }
    
                    length = #s;

                    i = 0;

                    findWordsK2a is (s, log) {

                        // base case
                        if dict has s {
                            //log "FOUND `s`\n";
                            reply [s];
                        }
    
                        length = #s;

                        i = 0;

                        while i < length {

                            // strings are just arrays
                            word = s[0..i];

                            if dict has word {

                                //log "FOUND `word`\n";

                                // we need to use the native form to branch on the result because findWords can fail;
                                // on failure we just keep chugging; on success we return
            
                                findWords <- (s[i+1..], log) -> (following) {
                                    reply [word] >< following;
                                }
                            }

                            i++;
                        }

                        // we seem to have run out of string
                        fail;
                    };

                    while i < length {

                        // strings are just arrays
                        word = s[0..i];

                        if dict has word {

                            //log "FOUND `word`\n";

                            // we need to use the native form to branch on the result because findWords can fail;
                            // on failure we just keep chugging; on success we return
            
                            findWords <- (s[i+1..], log) -> (following) {
                                reply [word] >< following;
                            }
                        }

                        i++;
                    }

                    // we seem to have run out of string
                    fail;
                };
    

                while i < length {

                    // strings are just arrays
                    word = s[0..i];

                    if dict has word {

                        //log "FOUND `word`\n";

                        // we need to use the native form to branch on the result because findWords can fail;
                        // on failure we just keep chugging; on success we return
            
                        findWords <- (s[i+1..], log) -> (following) {
                            reply [word] >< following;
                        }
                    }

                    i++;
                }

                // we seem to have run out of string
                fail;
            };

            while i < length {

                // strings are just arrays
                word = s[0..i];

                if dict has word {

                    //log "FOUND `word`\n";

                    // we need to use the native form to branch on the result because findWords can fail;
                    // on failure we just keep chugging; on success we return
            
                    findWords <- (s[i+1..], log) -> (following) {
                        reply [word] >< following;
                    }
                }

                i++;
            }

            // we seem to have run out of string
            fail;
        };

        while i < length {

            // strings are just arrays
            word = s[0..i];

            if dict has word {

                //log "FOUND `word`\n";

                // we need to use the native form to branch on the result because findWords can fail;
                // on failure we just keep chugging; on success we return
            
                findWords <- (s[i+1..], log) -> (following) {
                    reply [word] >< following;
                }
            }

            i++;
        }

        // we seem to have run out of string
        fail;
    };

    while i < length {

        // strings are just arrays
        word = s[0..i];

        if dict has word {

            //log "FOUND `word`\n";

            // we need to use the native form to branch on the result because findWords can fail;
            // on failure we just keep chugging; on success we return
            
            findWords <- (s[i+1..], log) -> (following) {
                reply [word] >< following;
            }
        }

        i++;
    }

    // we seem to have run out of string
    fail;
};



