/**
 * Another interview question solution.
 *
 * Created by: spurcell
 * 2/8/15
 */

dict is {
    "hi","high","land","highland","highlander","the","there","can","be","only","one","on","here","and","an"
};


findWords is (s, log) {

    // base case
    if dict has s {
        reply [s];
    }
    
    length = #s;

    i = 0;

    while i < length {

        // strings are just arrays
        word = s[0..i];

        if dict has word {

            // log("FOUND `word`\n");

            // we need to use the native form to branch on the result because findWords can fail;
            // on failure we just keep chugging; on success we return
            
            findWords <- (s[i+1..], log) -> (following) {
                reply [word] >< following;
            }
        }

        i++;
    }

    // we seem to have run out of string
    fail;
};

// todo -- system of passing in files securely

// idea: a service spec is an input format, reply format, and failure format
// that's it -- no 'exceptions' can bypass the stack

main is (args, system) {
    
    log is system.err.write;
    
    findWords: "therecanbeonlyonehighlander", log -> (result) {
        system.out.write("success! found `result`\n");
    }
    ~> {
        system.out.write("I was not set up for success\n");
        fail;
    }
};


