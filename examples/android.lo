/**
 * This program is the answer to an interview question I like to ask:
 * how many valid android lockscreen patterns are there?
 *
 * Created by: spurcell
 * 12/6/2015
 */


NUM_POINTS is 9;
MIN_POINTS is 4;

// recursively iterate
// label points as 0-8

explore is (path) {

    point = 0;
    found = 0;

    while point < NUM_POINTS {

        valid = true;

        if path contains point {   // point already used
            valid = false;
        }
        
        // top edge
        else if path[-1] == 0 and point == 2 {
            valid = path contains 1;
        }
        else if path[-1] == 2 and point == 0 {
            valid = path contains 1;
        }
        
        // middle horizontal
        else if path[-1] == 3 and point == 5 {
            valid = path contains 4;
        }
        else if path[-1] == 5 and point == 3 {
            valid = path contains 4;
        }
        
        // bottom edge
        else if path[-1] == 6 and point == 8 {
            valid = path contains 7;
        }
        else if path[-1] == 8 and point == 6 {
            valid = path contains 7;
        }
        
        // left edge
        else if path[-1] == 0 and point == 6 {
            valid = path contains 3;
        }
        else if path[-1] == 6 and point == 0 {
            valid = path contains 3;
        }
        
        // middle vertical
        else if path[-1] == 1 and point == 7 {
            valid = path contains 4;
        }
        else if path[-1] == 7 and point == 1 {
            valid = path contains 4;
        }
        
        // right edge
        else if path[-1] == 2 and point == 8 {
            valid = path contains 5;
        }
        else if path[-1] == 8 and point == 2 {
            valid = path contains 5;
        }
        
        // diagonals
        else if path[-1] == 0 and point == 8 {
            valid = path contains 4;
        }
        else if path[-1] == 8 and point == 0 {
            valid = path contains 4;
        }
        else if path[-1] == 2 and point == 6 {
            valid = path contains 4;
        }
        else if path[-1] == 6 and point == 2 {
            valid = path contains 4;
        }

        if valid {

            newLength = #path + 1;

            // see if path is long enough
            if newLength >= MIN_POINTS {
                found++;
            }

            // extend the path if possible
            if newLength < NUM_POINTS {
                found += explore(path >< [point]);
            }
        }

        point++;
    }

    reply found;
};

main is (args, system) {

    // for this problem we want a sequence, since a path has order, but we also want const time lookup of what we've used
    // we can just use a set for that

    system.out.write: "`explore([])`\n";
};
